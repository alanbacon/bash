bash for python
===============

A library that enables easy running and concatenation of bash commands in
python

Installation
------------

Install using pip::

    pip install bash


Usage
-----

Run commands as you would in bash::

    >>> from bash import bash
    >>> bash('ls . | grep ".pyc"')
    bash.pyc
    tests.pyc

Pass in arguments as an array::

    >>> bash('ls', ['.'])
    bash.pyc
    tests.pyc

Chain commands for the same pipe effect as above::

    >>> bash('ls . ').bash('grep ".pyc"')
    bash.pyc
    tests.pyc

Also chain using the ``xargs`` function to map the results of the previous command onto a new command::

    >>> bash('ls').bash('grep "\.py"').xargs('grep "author=\'Alex Couper\'"')
    'setup.py:    author=\'Alex Couper\','

Equivalently::
    >>> files = [f for f in bash('ls').bash('grep "\.py"')]
    >>> bash('grep "author=\'Alex Couper\'"', files)
    'setup.py:    author=\'Alex Couper\','


This becomes increasingly useful if you later need to reuse one such command::

    >>> b = bash('ls . ')
    >>> b.bash('grep ".pyc"')
    bash.pyc
    tests.pyc
    >>> b.bash('grep ".py$')
    bash.py
    tests.py

Access stdout and stderr attributes::

    >>> b = bash('ls tests.py')
    >>> b.stdout
    'tests.py\n'
    >>> b.stderr
    ''

Get the return code generated by a command::

    >>> b = bash('ls tests.py')
    >>> b
    tests.py
    >>> b.code
    0


To get a stripped, unicode string version of bash.stdout call value()::

    >>> b = bash('ls tests.py').value()
    u'tests.py'

To get the results (separated by newlines) as a list::

    >>> b = bash('ls . ').results()
    ['bash.pyc', 'tests.pyc']

or use the iterator directly::

    >>> b = [res for res in bash('ls . ')]
    ['bash.pyc', 'tests.pyc']

Motivation
----------

I found that I was often having to write the same lines of code to handle
running bash commands from python.

This provides a pip-installable, tested shortcut to writing::

    from subprocess import PIPE, Popen

    p = Popen(cmd, shell=True, stdout=PIPE, stdin=PIPE, stderr=PIPE)
    output, err = p.communicate()


Warning
-------

Please note that this library uses ``shell=True`` under the hood. This means
that this library is **NOT** suitable for running untrusted commands.
`(See explanation) <https://docs.python.org/2/library/subprocess.html#frequently-used-arguments>`_


Running the tests
-----------------

Simply use a test runner.

    $ nosetests

Support + Contributing
----------------------

Feel free to make pull requests, or report issues via the repo:

https://github.com/alexcouper/bash
